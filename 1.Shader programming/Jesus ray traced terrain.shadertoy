#define MAX_HEIGHT 60.0
#define MAX_DISTANCE 400.0
#define NOISE_SCALE 0.03
#define WATER_HEIGHT 23.0

#define PI 3.14159265359

float hash( float n )
{
  return fract(cos(n)*41375.92653);
}

float noise2(in vec2 x)
{
  vec2 p  = floor(x);
  vec2 f  = smoothstep(0.0, 1.0, fract(x));
  float n = p.x + p.y*57.0;

  return mix(
      mix(hash(n+0.0),  hash(n+1.0),  f.x),
      mix(hash(n+57.0), hash(n+58.0), f.x),
      f.y);
}

float fbm(in vec2 x)
{
    float val = 0.5 * noise2(x);
    val += 0.25 * noise2(2.01 * x);
    val += 0.12 * noise2(4.03 * x);
    val += 0.06 * noise2(7.99 * x);
    val += 0.03 * noise2(16.02 * x);
    //val += 0.01 * noise2(32.04 * x);
    return val/0.96;
}

float fbmDetailed(in vec2 x)
{
    float val = 0.5 * noise2(x);
    val += 0.25 * noise2(2.01 * x);
    val += 0.12 * noise2(4.03 * x);
    val += 0.06 * noise2(7.99 * x);
    val += 0.03 * noise2(16.02 * x);
    //val += 0.01 * noise2(32.04 * x);
    val += 0.002 * noise2(512.01 * x);
    return val/0.962;
}

float heightmap(in vec2 p)
{
    float height = MAX_HEIGHT * fbm(NOISE_SCALE * p);
    return height;
}

float heightmapDetailed(in vec2 p)
{
    float height = MAX_HEIGHT * fbmDetailed(NOISE_SCALE * p);
    return height;
}

vec3 terrainNormal(in vec3 p)
{
    float eps = 0.3;
    vec3 v1 = p - vec3(p.x-eps, heightmap(p.xz - vec2(eps,0.0)), p.z);
    vec3 v2 = p - vec3(p.x,     heightmap(p.xz - vec2(0.0,eps)), p.z-eps);
    vec3 n = normalize(cross(v2, v1));
    return n;
}

vec3 terrainNormalDetailed(in vec3 p)
{
    float eps = 0.3;
    vec3 v1 = p - vec3(p.x-eps, heightmapDetailed(p.xz - vec2(eps,0.0)), p.z);
    vec3 v2 = p - vec3(p.x,     heightmapDetailed(p.xz - vec2(0.0,eps)), p.z-eps);
    vec3 n = normalize(cross(v2, v1));
    return n;
}

float fresnel(in vec3 eyeDir, float R0)
{
    return R0 + (1.0 - R0)*pow(1.0 - dot(eyeDir, vec3(0.0,1.0,0.0)), 5.0);
}

vec3 terrainColor(in vec3 p)
{
    float h = p.y;
    float h2 = h + 5.0 * (2.0 * fbm(p.xz) - 1.0);
    vec3 col = vec3(0.1,0.3,0.0);
    col = mix(col, vec3(0.5,0.5,0.2), smoothstep(WATER_HEIGHT + 4.0, WATER_HEIGHT + 7.0, h2));
    col = mix(col, vec3(0.9,0.6,0.3), smoothstep(WATER_HEIGHT + 12.0, WATER_HEIGHT + 15.0, h2));
    col = mix(col, vec3(1.0,1.0,1.0), smoothstep(WATER_HEIGHT + 24.0, WATER_HEIGHT + 27.0, h2));
    col = mix(col, vec3(0.2, 0.15, 0.1), 1.0 - smoothstep(WATER_HEIGHT, WATER_HEIGHT + 0.5, h));
    return col;
    
    #if 0
    float h = p.y / MAX_HEIGHT;
    float h2 = h + 0.07*(2.0 * fbm(p.xz) - 1.0);
    vec3 col = vec3(0.1,0.3,0.0);
    col = mix(col, vec3(0.5,0.5,0.2), smoothstep(0.54, 0.58, h2));
    col = mix(col, vec3(0.9,0.6,0.3), smoothstep(0.60, 0.64, h2));
    col = mix(col, vec3(1.0,1.0,1.0), smoothstep(0.68, 0.72, h2));
    col = mix(col, vec3(0.2, 0.15, 0.1), 1.0 - smoothstep(0.46, 0.465, h));
    return col;
    #endif
}

vec3 horizonCol = vec3(0.8, 0.95, 1.0);

vec3 skyColor(in vec3 d)
{
    vec3 skyCol = vec3(0.1, 0.4, 0.8);
    
    vec2 uv = d.xz / d.y;
    float cloudFactor = min(1.0, max(0.0, fbm(uv+iTime*0.05) - 0.5) * 15.0);
    skyCol = mix(skyCol, vec3(1.0), cloudFactor * d.y);
    
    skyCol = mix(horizonCol, skyCol, sqrt(abs(d.y)));
    
    return skyCol;
}

float intersectTerrain(in vec3 o, in vec3 d)
{
    vec3 p = o;
    float t0 = 0.0;
    float t = 0.0;
    float delta = 0.0;
    float h = 0.0;
    bool hit = false;
    bool involume = true;

    for (int i = 0; i < 140 && !hit && involume; ++i)
    {
        delta = max(0.01, 0.2*abs(p.y - h)) + t * 0.01;
        t0 = t;
        t += delta;
        
        p = o + t * d;
        h = heightmap(p.xz);
        hit = (p.y < h);
        involume = (p.y < MAX_HEIGHT) && (t < MAX_DISTANCE);
    }

    if (hit)
    {
        // binary search
        for (int i = 0; i < 10; ++i)
        {
            float tc = 0.5 * (t0 + t);
        	p = o + tc * d;

        	h = heightmap(p.xz);
            
        	if (p.y < h)
        	{
                t = tc;
                t0 = t0;
        	}
            else
            {
                t = t;
                t0 = tc;
            }
        }
        
        return t;
    }
    
    return 0.0;
}

float calcAO(in vec3 p, in vec3 n)
{
    float ao = 0.0;
    float r1 = 1.0;
    float r2 = 1.0;
    float r3 = 1.0;
    vec3 uu = normalize(cross(vec3(1.0,0.0,0.0), n));
    vec3 vv = n;
    vec3 ww = cross(vv, uu);
    mat3 rot = mat3(uu, vv, ww);
    for (int i = 0; i < 6; ++i)
    {
        r1 = hash(435.627*r1) * 2.0 - 1.0;
        r2 = hash(513.128*r2) * 2.0 - 1.0;
    	r3 = hash(198.731*r3);
        vec3 disp = rot * vec3(r1,r3,r2) * float(i) * 1.0;
        vec3 pb = p + disp;
        float h = heightmap(pb.xz);
        ao += max(0.0, smoothstep(float(i), 0.0, pb.y - h));
    }
    ao = 1.0 - ao/6.0;
    ao *= ao;
    return ao;
}

vec3 shadeTerrain(in vec3 p)
{
    vec3 col = vec3(0.0);
    
    // AO
    float h = p.y;
    vec3 n = terrainNormalDetailed(p);
    float ao = calcAO(p, n);
    vec3 mcolor = terrainColor(p);

    // ambient
    vec3 acolor = 0.5*vec3(0.5, 0.5, 0.6);
    float amb = max(0.0, dot(0.5*n + 0.5, vec3(0.0, 1.0, 0.0)));
    col += vec3(mcolor * acolor * amb * ao);

    // diffuse
    vec3 l = normalize(vec3(0.5, 1.0, 2.0));
    vec3 dcolor = vec3(0.5, 0.5, 0.4);
    float dif = max(0.0, dot(n, l));
    col += vec3(mcolor * dcolor * dif);
    
    return col;
}

vec3 shadeWater(in vec3 obs, in vec3 p, in vec3 d, float groundDepth, in vec3 groundColor)
{
    // normal
    vec2 eps = vec2(0.1,0.0);
    vec3 n0 =      vec3(p.x        , fbm(3.0*p.xz + eps.yy + iTime), p.z);
    vec3 n1 = n0 - vec3(p.x + eps.x, fbm(3.0*p.xz + eps.xy + iTime), p.z);
    vec3 n2 = n0 - vec3(p.x        , fbm(3.0*p.xz + eps.yx + iTime), p.z + eps.x);
    vec3 n = cross(n1, n2);
    float att = length(obs - p) * 1.5;
    n.y *= att;
    n = normalize(n);
    
    // reflection
    vec3 r = reflect(d, n);
    vec3 reflectedCol = skyColor(r);
    float t = intersectTerrain(p, r);
    if (t > 0.0)
    {
        vec3 p = p + t*r;
        reflectedCol = shadeTerrain(p);
    }
    
    // refraction
    vec3 deepBlue = vec3(0.0,0.05,0.2);
    vec3 refractedCol = mix(deepBlue, groundColor, exp(-groundDepth*0.5));
    
    float f = fresnel(-d, 0.03);
    vec3 col = mix(refractedCol, reflectedCol, f);
	return col;
}

vec3 cameraPos(float time)
{
    float speed = 5.0;
    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));
    vec3 pos = vec3(0.0, 0.0, 0.0) + speed*time*dir;
    pos.y = heightmap(pos.xz) + 5.0;
    pos.y = max(pos.y,WATER_HEIGHT + 5.0);
    return pos;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;
    uv.x *= iResolution.x/iResolution.y;
    
    // camera
    float tf = mod(iTime, 1.0);
    float t1 = iTime - tf;
    float t2 = t1 + 1.0;
    vec3 o1 = cameraPos(t1);
    vec3 o2 = cameraPos(t2);
    vec3 o = cameraPos(iTime);
    o.y = mix(o1.y, o2.y, tf/1.0);
    
    vec3 c = o + vec3(cos(PI*iMouse.x/iResolution.x), 4.0*sin(iMouse.y/iResolution.y-0.5)-0.5, sin(PI*iMouse.x/iResolution.x));
    vec3 ww = normalize(o - c);
    vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));
    vec3 vv = cross(ww, uu);
    vec3 d = normalize(uu * uv.x + vv * uv.y - ww * 2.8);

#if 0
    // height projected on floor
    float tf = -o.y / d.y;
    if (tf > 0.0)
    {
       	vec3 p = o + tf * d;
        fragColor = vec4(vec3(fbm(0.04*p.xz)), 1.0);
        return;
    }
#endif
    
    vec3 col = vec3(0.0);
    
    float t = intersectTerrain(o, d);
        
    if (t > 0.0)
    {
        vec3 p = o + t * d;
        
        col = shadeTerrain(p);
        
    	// water
        if (p.y < WATER_HEIGHT)
        {
	    	float t2 = (WATER_HEIGHT-o.y) / d.y;        
       		vec3 waterPos = o + t2 * d;
            
            col = shadeWater(o, waterPos, d, length(p - waterPos), col);
        }
        
        col = mix(horizonCol, col, 1.0 - smoothstep(0.0, MAX_DISTANCE, t));//exp(-t*0.001));
    }
    else
    {
   		col = skyColor(d);
    }
    
#if 0
    // show material gradient
    if (uv.y < -0.5)
    {   
        vec3 p = vec3(uv.x, MAX_HEIGHT*(uv.x * 0.5 + 0.5), uv.y);
        col = colormap(p);
    }
#endif
    
    col = sqrt(col);
    
    
    // Output to screen
    fragColor = vec4(col,1.0);
}